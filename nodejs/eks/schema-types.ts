/* tslint:disable */
/**
 * This file was automatically generated by pulumi-provider-scripts.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source Pulumi Schema file,
 * and run "pulumi-provider-scripts gen-provider-types" to regenerate this file. */
import * as pulumi from "@pulumi/pulumi";
export type ConstructComponent<T extends pulumi.ComponentResource = pulumi.ComponentResource> = (name: string, inputs: any, options: pulumi.ComponentResourceOptions) => T;
export type ResourceConstructor = {
    readonly "eks:index:Cluster": ConstructComponent<Cluster>;
    readonly "eks:index:ClusterCreationRoleProvider": ConstructComponent<ClusterCreationRoleProvider>;
    readonly "eks:index:ManagedNodeGroup": ConstructComponent<ManagedNodeGroup>;
    readonly "eks:index:NodeGroup": ConstructComponent<NodeGroup>;
    readonly "eks:index:NodeGroupSecurityGroup": ConstructComponent<NodeGroupSecurityGroup>;
    readonly "eks:index:NodeGroupV2": ConstructComponent<NodeGroupV2>;
    readonly "eks:index:VpcCni": ConstructComponent<VpcCni>;
};
export type Functions = {
    "eks:index:Cluster/getKubeconfig": (inputs: Cluster_getKubeconfigInputs) => Promise<Cluster_getKubeconfigOutputs>;
};
import * as aws from "@pulumi/aws";
import * as kubernetes from "@pulumi/kubernetes";
export abstract class Cluster<TData = any> extends (pulumi.ComponentResource)<TData> {
    public awsProvider!: unknown | pulumi.Output<unknown>;
    public clusterSecurityGroup!: aws.ec2.SecurityGroup | pulumi.Output<aws.ec2.SecurityGroup>;
    public core!: CoreDataOutputs | pulumi.Output<CoreDataOutputs>;
    public defaultNodeGroup?: NodeGroupDataOutputs | pulumi.Output<NodeGroupDataOutputs>;
    public eksCluster!: aws.eks.Cluster | pulumi.Output<aws.eks.Cluster>;
    public eksClusterIngressRule!: aws.ec2.SecurityGroupRule | pulumi.Output<aws.ec2.SecurityGroupRule>;
    public instanceRoles!: aws.iam.Role[] | pulumi.Output<aws.iam.Role[]>;
    public kubeconfig!: any | pulumi.Output<any>;
    public nodeSecurityGroup!: aws.ec2.SecurityGroup | pulumi.Output<aws.ec2.SecurityGroup>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:Cluster", name, opts.urn ? { awsProvider: undefined, clusterSecurityGroup: undefined, core: undefined, defaultNodeGroup: undefined, eksCluster: undefined, eksClusterIngressRule: undefined, instanceRoles: undefined, kubeconfig: undefined, nodeSecurityGroup: undefined } : { name, args, opts }, opts);
    }
}
export interface ClusterArgs {
    readonly clusterSecurityGroup?: pulumi.Input<aws.ec2.SecurityGroup>;
    readonly clusterSecurityGroupTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly clusterTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly createOidcProvider?: pulumi.Input<boolean>;
    readonly creationRoleProvider?: pulumi.Input<CreationRoleProviderInputs>;
    readonly defaultAddonsToRemove?: pulumi.Input<pulumi.Input<string>[]>;
    readonly desiredCapacity?: pulumi.Input<number>;
    readonly enabledClusterLogTypes?: pulumi.Input<pulumi.Input<string>[]>;
    readonly encryptRootBlockDevice?: pulumi.Input<boolean>;
    readonly encryptionConfigKeyArn?: pulumi.Input<string>;
    readonly endpointPrivateAccess?: pulumi.Input<boolean>;
    readonly endpointPublicAccess?: pulumi.Input<boolean>;
    readonly fargate?: pulumi.Input<unknown>;
    readonly gpu?: pulumi.Input<boolean>;
    readonly instanceProfileName?: pulumi.Input<string>;
    readonly instanceRole?: pulumi.Input<aws.iam.Role>;
    readonly instanceRoles?: pulumi.Input<pulumi.Input<aws.iam.Role>[]>;
    readonly instanceType?: pulumi.Input<string>;
    readonly kubernetesServiceIpAddressRange?: pulumi.Input<string>;
    readonly maxSize?: pulumi.Input<number>;
    readonly minSize?: pulumi.Input<number>;
    readonly name?: pulumi.Input<string>;
    readonly nodeAmiId?: pulumi.Input<string>;
    readonly nodeAssociatePublicIpAddress?: pulumi.Input<boolean>;
    readonly nodeGroupOptions?: pulumi.Input<ClusterNodeGroupOptionsInputs>;
    readonly nodePublicKey?: pulumi.Input<string>;
    readonly nodeRootVolumeDeleteOnTermination?: pulumi.Input<boolean>;
    readonly nodeRootVolumeEncrypted?: pulumi.Input<boolean>;
    readonly nodeRootVolumeIops?: pulumi.Input<number>;
    readonly nodeRootVolumeSize?: pulumi.Input<number>;
    readonly nodeRootVolumeThroughput?: pulumi.Input<number>;
    readonly nodeRootVolumeType?: pulumi.Input<string>;
    readonly nodeSecurityGroupTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly nodeSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly nodeUserData?: pulumi.Input<string>;
    readonly privateSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly providerCredentialOpts?: pulumi.Input<KubeconfigOptionsInputs>;
    readonly proxy?: pulumi.Input<string>;
    readonly publicAccessCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    readonly publicSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly roleMappings?: pulumi.Input<pulumi.Input<RoleMappingInputs>[]>;
    readonly serviceRole?: pulumi.Input<aws.iam.Role>;
    readonly skipDefaultNodeGroup?: pulumi.Input<boolean>;
    readonly storageClasses?: pulumi.Input<unknown>;
    readonly subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly tags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly useDefaultVpcCni?: pulumi.Input<boolean>;
    readonly userMappings?: pulumi.Input<pulumi.Input<UserMappingInputs>[]>;
    readonly version?: pulumi.Input<string>;
    readonly vpcCniOptions?: pulumi.Input<VpcCniOptionsInputs>;
    readonly vpcId?: pulumi.Input<string>;
}
export abstract class ClusterCreationRoleProvider<TData = any> extends (pulumi.ComponentResource)<TData> {
    public provider!: unknown | pulumi.Output<unknown>;
    public role!: aws.iam.Role | pulumi.Output<aws.iam.Role>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:ClusterCreationRoleProvider", name, opts.urn ? { provider: undefined, role: undefined } : { name, args, opts }, opts);
    }
}
export interface ClusterCreationRoleProviderArgs {
    readonly profile?: pulumi.Input<string>;
    readonly region?: pulumi.Input<string>;
}
export abstract class ManagedNodeGroup<TData = any> extends (pulumi.ComponentResource)<TData> {
    public nodeGroup!: aws.eks.NodeGroup | pulumi.Output<aws.eks.NodeGroup>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:ManagedNodeGroup", name, opts.urn ? { nodeGroup: undefined } : { name, args, opts }, opts);
    }
}
export interface ManagedNodeGroupArgs {
    readonly amiType?: pulumi.Input<string>;
    readonly capacityType?: pulumi.Input<string>;
    readonly cluster: pulumi.Input<CoreDataInputs>;
    readonly clusterName?: pulumi.Input<string>;
    readonly diskSize?: pulumi.Input<number>;
    readonly forceUpdateVersion?: pulumi.Input<boolean>;
    readonly instanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    readonly labels?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly launchTemplate?: pulumi.Input<aws.types.input.eks.NodeGroupLaunchTemplate>;
    readonly nodeGroupName?: pulumi.Input<string>;
    readonly nodeGroupNamePrefix?: pulumi.Input<string>;
    readonly nodeRole?: pulumi.Input<aws.iam.Role>;
    readonly nodeRoleArn?: pulumi.Input<string>;
    readonly releaseVersion?: pulumi.Input<string>;
    readonly remoteAccess?: pulumi.Input<aws.types.input.eks.NodeGroupRemoteAccess>;
    readonly scalingConfig?: pulumi.Input<aws.types.input.eks.NodeGroupScalingConfig>;
    readonly subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly tags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly taints?: pulumi.Input<pulumi.Input<aws.types.input.eks.NodeGroupTaint>[]>;
    readonly version?: pulumi.Input<string>;
}
export abstract class NodeGroup<TData = any> extends (pulumi.ComponentResource)<TData> {
    public autoScalingGroupName!: string | pulumi.Output<string>;
    public cfnStack!: aws.cloudformation.Stack | pulumi.Output<aws.cloudformation.Stack>;
    public extraNodeSecurityGroups!: aws.ec2.SecurityGroup[] | pulumi.Output<aws.ec2.SecurityGroup[]>;
    public nodeSecurityGroup!: aws.ec2.SecurityGroup | pulumi.Output<aws.ec2.SecurityGroup>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:NodeGroup", name, opts.urn ? { autoScalingGroupName: undefined, cfnStack: undefined, extraNodeSecurityGroups: undefined, nodeSecurityGroup: undefined } : { name, args, opts }, opts);
    }
}
export interface NodeGroupArgs {
    readonly amiId?: pulumi.Input<string>;
    readonly amiType?: pulumi.Input<string>;
    readonly autoScalingGroupTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly bootstrapExtraArgs?: pulumi.Input<string>;
    readonly cloudFormationTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly cluster: pulumi.Input<CoreDataInputs>;
    readonly clusterIngressRule?: pulumi.Input<aws.ec2.SecurityGroupRule>;
    readonly desiredCapacity?: pulumi.Input<number>;
    readonly encryptRootBlockDevice?: pulumi.Input<boolean>;
    readonly extraNodeSecurityGroups?: pulumi.Input<pulumi.Input<aws.ec2.SecurityGroup>[]>;
    readonly gpu?: pulumi.Input<boolean>;
    readonly instanceProfile?: pulumi.Input<aws.iam.InstanceProfile>;
    readonly instanceType?: pulumi.Input<string>;
    readonly keyName?: pulumi.Input<string>;
    readonly kubeletExtraArgs?: pulumi.Input<string>;
    readonly labels?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly maxSize?: pulumi.Input<number>;
    readonly minSize?: pulumi.Input<number>;
    readonly nodeAssociatePublicIpAddress?: pulumi.Input<boolean>;
    readonly nodePublicKey?: pulumi.Input<string>;
    readonly nodeRootVolumeSize?: pulumi.Input<number>;
    readonly nodeSecurityGroup?: pulumi.Input<aws.ec2.SecurityGroup>;
    readonly nodeSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly nodeUserData?: pulumi.Input<string>;
    readonly nodeUserDataOverride?: pulumi.Input<string>;
    readonly spotPrice?: pulumi.Input<string>;
    readonly taints?: pulumi.Input<Record<string, pulumi.Input<TaintInputs>>>;
    readonly version?: pulumi.Input<string>;
}
export abstract class NodeGroupSecurityGroup<TData = any> extends (pulumi.ComponentResource)<TData> {
    public securityGroup!: aws.ec2.SecurityGroup | pulumi.Output<aws.ec2.SecurityGroup>;
    public securityGroupRule!: aws.ec2.SecurityGroupRule | pulumi.Output<aws.ec2.SecurityGroupRule>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:NodeGroupSecurityGroup", name, opts.urn ? { securityGroup: undefined, securityGroupRule: undefined } : { name, args, opts }, opts);
    }
}
export interface NodeGroupSecurityGroupArgs {
    readonly clusterSecurityGroup: pulumi.Input<aws.ec2.SecurityGroup>;
    readonly eksCluster: pulumi.Input<aws.eks.Cluster>;
    readonly tags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly vpcId: pulumi.Input<string>;
}
export abstract class NodeGroupV2<TData = any> extends (pulumi.ComponentResource)<TData> {
    public autoScalingGroup!: aws.autoscaling.Group | pulumi.Output<aws.autoscaling.Group>;
    public extraNodeSecurityGroups!: aws.ec2.SecurityGroup[] | pulumi.Output<aws.ec2.SecurityGroup[]>;
    public nodeSecurityGroup!: aws.ec2.SecurityGroup | pulumi.Output<aws.ec2.SecurityGroup>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:NodeGroupV2", name, opts.urn ? { autoScalingGroup: undefined, extraNodeSecurityGroups: undefined, nodeSecurityGroup: undefined } : { name, args, opts }, opts);
    }
}
export interface NodeGroupV2Args {
    readonly amiId?: pulumi.Input<string>;
    readonly amiType?: pulumi.Input<string>;
    readonly autoScalingGroupTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly bootstrapExtraArgs?: pulumi.Input<string>;
    readonly cloudFormationTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly cluster: pulumi.Input<CoreDataInputs>;
    readonly clusterIngressRule?: pulumi.Input<aws.ec2.SecurityGroupRule>;
    readonly desiredCapacity?: pulumi.Input<number>;
    readonly encryptRootBlockDevice?: pulumi.Input<boolean>;
    readonly extraNodeSecurityGroups?: pulumi.Input<pulumi.Input<aws.ec2.SecurityGroup>[]>;
    readonly gpu?: pulumi.Input<boolean>;
    readonly instanceProfile?: pulumi.Input<aws.iam.InstanceProfile>;
    readonly instanceType?: pulumi.Input<string>;
    readonly keyName?: pulumi.Input<string>;
    readonly kubeletExtraArgs?: pulumi.Input<string>;
    readonly labels?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly maxSize?: pulumi.Input<number>;
    readonly minRefreshPercentage?: pulumi.Input<number>;
    readonly minSize?: pulumi.Input<number>;
    readonly nodeAssociatePublicIpAddress?: pulumi.Input<boolean>;
    readonly nodePublicKey?: pulumi.Input<string>;
    readonly nodeRootVolumeSize?: pulumi.Input<number>;
    readonly nodeSecurityGroup?: pulumi.Input<aws.ec2.SecurityGroup>;
    readonly nodeSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly nodeUserData?: pulumi.Input<string>;
    readonly nodeUserDataOverride?: pulumi.Input<string>;
    readonly spotPrice?: pulumi.Input<string>;
    readonly taints?: pulumi.Input<Record<string, pulumi.Input<TaintInputs>>>;
    readonly version?: pulumi.Input<string>;
}
export abstract class VpcCni<TData = any> extends (pulumi.ComponentResource)<TData> {
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("eks:index:VpcCni", name, opts.urn ? {} : { name, args, opts }, opts);
    }
}
export interface VpcCniArgs {
    readonly cniConfigureRpfilter?: pulumi.Input<boolean>;
    readonly cniCustomNetworkCfg?: pulumi.Input<boolean>;
    readonly cniExternalSnat?: pulumi.Input<boolean>;
    readonly customNetworkConfig?: pulumi.Input<boolean>;
    readonly disableTcpEarlyDemux?: pulumi.Input<boolean>;
    readonly enableIpv6?: pulumi.Input<boolean>;
    readonly enablePodEni?: pulumi.Input<boolean>;
    readonly enablePrefixDelegation?: pulumi.Input<boolean>;
    readonly eniConfigLabelDef?: pulumi.Input<string>;
    readonly eniMtu?: pulumi.Input<number>;
    readonly externalSnat?: pulumi.Input<boolean>;
    readonly image?: pulumi.Input<string>;
    readonly initImage?: pulumi.Input<string>;
    readonly kubeconfig: pulumi.Input<any>;
    readonly logFile?: pulumi.Input<string>;
    readonly logLevel?: pulumi.Input<string>;
    readonly nodePortSupport?: pulumi.Input<boolean>;
    readonly securityContextPrivileged?: pulumi.Input<boolean>;
    readonly vethPrefix?: pulumi.Input<string>;
    readonly warmEniTarget?: pulumi.Input<number>;
    readonly warmIpTarget?: pulumi.Input<number>;
    readonly warmPrefixTarget?: pulumi.Input<number>;
}
export interface ClusterNodeGroupOptionsInputs {
    readonly amiId?: pulumi.Input<string>;
    readonly amiType?: pulumi.Input<string>;
    readonly autoScalingGroupTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly bootstrapExtraArgs?: pulumi.Input<string>;
    readonly cloudFormationTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly clusterIngressRule?: pulumi.Input<aws.ec2.SecurityGroupRule>;
    readonly desiredCapacity?: pulumi.Input<number>;
    readonly encryptRootBlockDevice?: pulumi.Input<boolean>;
    readonly extraNodeSecurityGroups?: pulumi.Input<pulumi.Input<aws.ec2.SecurityGroup>[]>;
    readonly gpu?: pulumi.Input<boolean>;
    readonly instanceProfile?: pulumi.Input<aws.iam.InstanceProfile>;
    readonly instanceType?: pulumi.Input<string>;
    readonly keyName?: pulumi.Input<string>;
    readonly kubeletExtraArgs?: pulumi.Input<string>;
    readonly labels?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly maxSize?: pulumi.Input<number>;
    readonly minSize?: pulumi.Input<number>;
    readonly nodeAssociatePublicIpAddress?: pulumi.Input<boolean>;
    readonly nodePublicKey?: pulumi.Input<string>;
    readonly nodeRootVolumeSize?: pulumi.Input<number>;
    readonly nodeSecurityGroup?: pulumi.Input<aws.ec2.SecurityGroup>;
    readonly nodeSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly nodeUserData?: pulumi.Input<string>;
    readonly nodeUserDataOverride?: pulumi.Input<string>;
    readonly spotPrice?: pulumi.Input<string>;
    readonly taints?: pulumi.Input<Record<string, pulumi.Input<TaintInputs>>>;
    readonly version?: pulumi.Input<string>;
}
export interface ClusterNodeGroupOptionsOutputs {
    readonly amiId?: pulumi.Output<string>;
    readonly amiType?: pulumi.Output<string>;
    readonly autoScalingGroupTags?: pulumi.Output<Record<string, string>>;
    readonly bootstrapExtraArgs?: pulumi.Output<string>;
    readonly cloudFormationTags?: pulumi.Output<Record<string, string>>;
    readonly clusterIngressRule?: pulumi.Output<aws.ec2.SecurityGroupRule>;
    readonly desiredCapacity?: pulumi.Output<number>;
    readonly encryptRootBlockDevice?: pulumi.Output<boolean>;
    readonly extraNodeSecurityGroups?: pulumi.Output<aws.ec2.SecurityGroup[]>;
    readonly gpu?: pulumi.Output<boolean>;
    readonly instanceProfile?: pulumi.Output<aws.iam.InstanceProfile>;
    readonly instanceType?: pulumi.Output<string>;
    readonly keyName?: pulumi.Output<string>;
    readonly kubeletExtraArgs?: pulumi.Output<string>;
    readonly labels?: pulumi.Output<Record<string, string>>;
    readonly maxSize?: pulumi.Output<number>;
    readonly minSize?: pulumi.Output<number>;
    readonly nodeAssociatePublicIpAddress?: pulumi.Output<boolean>;
    readonly nodePublicKey?: pulumi.Output<string>;
    readonly nodeRootVolumeSize?: pulumi.Output<number>;
    readonly nodeSecurityGroup?: pulumi.Output<aws.ec2.SecurityGroup>;
    readonly nodeSubnetIds?: pulumi.Output<string[]>;
    readonly nodeUserData?: pulumi.Output<string>;
    readonly nodeUserDataOverride?: pulumi.Output<string>;
    readonly spotPrice?: pulumi.Output<string>;
    readonly taints?: pulumi.Output<Record<string, TaintOutputs>>;
    readonly version?: pulumi.Output<string>;
}
export interface CoreDataInputs {
    readonly awsProvider?: pulumi.Input<unknown>;
    readonly cluster: pulumi.Input<aws.eks.Cluster>;
    readonly clusterIamRole: pulumi.Input<aws.iam.Role>;
    readonly clusterSecurityGroup: pulumi.Input<aws.ec2.SecurityGroup>;
    readonly eksNodeAccess?: pulumi.Input<kubernetes.core.v1.ConfigMap>;
    readonly encryptionConfig?: pulumi.Input<aws.types.input.eks.ClusterEncryptionConfig>;
    readonly endpoint: pulumi.Input<string>;
    readonly fargateProfile?: pulumi.Input<aws.eks.FargateProfile>;
    readonly instanceRoles: pulumi.Input<pulumi.Input<aws.iam.Role>[]>;
    readonly kubeconfig?: pulumi.Input<any>;
    readonly nodeGroupOptions: pulumi.Input<ClusterNodeGroupOptionsInputs>;
    readonly nodeSecurityGroupTags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly oidcProvider?: pulumi.Input<aws.iam.OpenIdConnectProvider>;
    readonly privateSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly provider: pulumi.Input<unknown>;
    readonly publicSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly storageClasses?: pulumi.Input<Record<string, pulumi.Input<kubernetes.storage.v1.StorageClass>>>;
    readonly subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    readonly tags?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly vpcCni?: pulumi.Input<VpcCni>;
    readonly vpcId: pulumi.Input<string>;
}
export interface CoreDataOutputs {
    readonly awsProvider?: pulumi.Output<unknown>;
    readonly cluster: pulumi.Output<aws.eks.Cluster>;
    readonly clusterIamRole: pulumi.Output<aws.iam.Role>;
    readonly clusterSecurityGroup: pulumi.Output<aws.ec2.SecurityGroup>;
    readonly eksNodeAccess?: pulumi.Output<kubernetes.core.v1.ConfigMap>;
    readonly encryptionConfig?: pulumi.Output<aws.types.output.eks.ClusterEncryptionConfig>;
    readonly endpoint: pulumi.Output<string>;
    readonly fargateProfile?: pulumi.Output<aws.eks.FargateProfile>;
    readonly instanceRoles: pulumi.Output<aws.iam.Role[]>;
    readonly kubeconfig?: pulumi.Output<any>;
    readonly nodeGroupOptions: pulumi.Output<ClusterNodeGroupOptionsOutputs>;
    readonly nodeSecurityGroupTags?: pulumi.Output<Record<string, string>>;
    readonly oidcProvider?: pulumi.Output<aws.iam.OpenIdConnectProvider>;
    readonly privateSubnetIds?: pulumi.Output<string[]>;
    readonly provider: pulumi.Output<unknown>;
    readonly publicSubnetIds?: pulumi.Output<string[]>;
    readonly storageClasses?: pulumi.Output<Record<string, kubernetes.storage.v1.StorageClass>>;
    readonly subnetIds: pulumi.Output<string[]>;
    readonly tags?: pulumi.Output<Record<string, string>>;
    readonly vpcCni?: pulumi.Output<VpcCni>;
    readonly vpcId: pulumi.Output<string>;
}
export interface CreationRoleProviderInputs {
    readonly provider: pulumi.Input<unknown>;
    readonly role: pulumi.Input<aws.iam.Role>;
}
export interface CreationRoleProviderOutputs {
    readonly provider: pulumi.Output<unknown>;
    readonly role: pulumi.Output<aws.iam.Role>;
}
export interface FargateProfileInputs {
    readonly podExecutionRoleArn?: pulumi.Input<string>;
    readonly selectors?: pulumi.Input<pulumi.Input<aws.types.input.eks.FargateProfileSelector>[]>;
    readonly subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
}
export interface FargateProfileOutputs {
    readonly podExecutionRoleArn?: pulumi.Output<string>;
    readonly selectors?: pulumi.Output<aws.types.output.eks.FargateProfileSelector[]>;
    readonly subnetIds?: pulumi.Output<string[]>;
}
export interface KubeconfigOptionsInputs {
    readonly profileName?: pulumi.Input<string>;
    readonly roleArn?: pulumi.Input<string>;
}
export interface KubeconfigOptionsOutputs {
    readonly profileName?: pulumi.Output<string>;
    readonly roleArn?: pulumi.Output<string>;
}
export interface NodeGroupDataInputs {
    readonly autoScalingGroupName: pulumi.Input<string>;
    readonly cfnStack: pulumi.Input<aws.cloudformation.Stack>;
    readonly extraNodeSecurityGroups: pulumi.Input<pulumi.Input<aws.ec2.SecurityGroup>[]>;
    readonly nodeSecurityGroup: pulumi.Input<aws.ec2.SecurityGroup>;
}
export interface NodeGroupDataOutputs {
    readonly autoScalingGroupName: pulumi.Output<string>;
    readonly cfnStack: pulumi.Output<aws.cloudformation.Stack>;
    readonly extraNodeSecurityGroups: pulumi.Output<aws.ec2.SecurityGroup[]>;
    readonly nodeSecurityGroup: pulumi.Output<aws.ec2.SecurityGroup>;
}
export interface RoleMappingInputs {
    readonly groups: pulumi.Input<pulumi.Input<string>[]>;
    readonly roleArn: pulumi.Input<string>;
    readonly username: pulumi.Input<string>;
}
export interface RoleMappingOutputs {
    readonly groups: pulumi.Output<string[]>;
    readonly roleArn: pulumi.Output<string>;
    readonly username: pulumi.Output<string>;
}
export interface StorageClassInputs {
    readonly allowVolumeExpansion?: pulumi.Input<boolean>;
    readonly default?: pulumi.Input<boolean>;
    readonly encrypted?: pulumi.Input<boolean>;
    readonly iopsPerGb?: pulumi.Input<number>;
    readonly kmsKeyId?: pulumi.Input<string>;
    readonly metadata?: pulumi.Input<kubernetes.types.input.meta.v1.ObjectMeta>;
    readonly mountOptions?: pulumi.Input<pulumi.Input<string>[]>;
    readonly reclaimPolicy?: pulumi.Input<string>;
    readonly type: pulumi.Input<string>;
    readonly volumeBindingMode?: pulumi.Input<string>;
    readonly zones?: pulumi.Input<pulumi.Input<string>[]>;
}
export interface StorageClassOutputs {
    readonly allowVolumeExpansion?: pulumi.Output<boolean>;
    readonly default?: pulumi.Output<boolean>;
    readonly encrypted?: pulumi.Output<boolean>;
    readonly iopsPerGb?: pulumi.Output<number>;
    readonly kmsKeyId?: pulumi.Output<string>;
    readonly metadata?: pulumi.Output<kubernetes.types.output.meta.v1.ObjectMeta>;
    readonly mountOptions?: pulumi.Output<string[]>;
    readonly reclaimPolicy?: pulumi.Output<string>;
    readonly type: pulumi.Output<string>;
    readonly volumeBindingMode?: pulumi.Output<string>;
    readonly zones?: pulumi.Output<string[]>;
}
export interface TaintInputs {
    readonly effect: pulumi.Input<string>;
    readonly value: pulumi.Input<string>;
}
export interface TaintOutputs {
    readonly effect: pulumi.Output<string>;
    readonly value: pulumi.Output<string>;
}
export interface UserMappingInputs {
    readonly groups: pulumi.Input<pulumi.Input<string>[]>;
    readonly userArn: pulumi.Input<string>;
    readonly username: pulumi.Input<string>;
}
export interface UserMappingOutputs {
    readonly groups: pulumi.Output<string[]>;
    readonly userArn: pulumi.Output<string>;
    readonly username: pulumi.Output<string>;
}
export interface VpcCniOptionsInputs {
    readonly cniConfigureRpfilter?: pulumi.Input<boolean>;
    readonly cniCustomNetworkCfg?: pulumi.Input<boolean>;
    readonly cniExternalSnat?: pulumi.Input<boolean>;
    readonly customNetworkConfig?: pulumi.Input<boolean>;
    readonly disableTcpEarlyDemux?: pulumi.Input<boolean>;
    readonly enableIpv6?: pulumi.Input<boolean>;
    readonly enablePodEni?: pulumi.Input<boolean>;
    readonly enablePrefixDelegation?: pulumi.Input<boolean>;
    readonly eniConfigLabelDef?: pulumi.Input<string>;
    readonly eniMtu?: pulumi.Input<number>;
    readonly externalSnat?: pulumi.Input<boolean>;
    readonly image?: pulumi.Input<string>;
    readonly initImage?: pulumi.Input<string>;
    readonly logFile?: pulumi.Input<string>;
    readonly logLevel?: pulumi.Input<string>;
    readonly nodePortSupport?: pulumi.Input<boolean>;
    readonly securityContextPrivileged?: pulumi.Input<boolean>;
    readonly vethPrefix?: pulumi.Input<string>;
    readonly warmEniTarget?: pulumi.Input<number>;
    readonly warmIpTarget?: pulumi.Input<number>;
    readonly warmPrefixTarget?: pulumi.Input<number>;
}
export interface VpcCniOptionsOutputs {
    readonly cniConfigureRpfilter?: pulumi.Output<boolean>;
    readonly cniCustomNetworkCfg?: pulumi.Output<boolean>;
    readonly cniExternalSnat?: pulumi.Output<boolean>;
    readonly customNetworkConfig?: pulumi.Output<boolean>;
    readonly disableTcpEarlyDemux?: pulumi.Output<boolean>;
    readonly enableIpv6?: pulumi.Output<boolean>;
    readonly enablePodEni?: pulumi.Output<boolean>;
    readonly enablePrefixDelegation?: pulumi.Output<boolean>;
    readonly eniConfigLabelDef?: pulumi.Output<string>;
    readonly eniMtu?: pulumi.Output<number>;
    readonly externalSnat?: pulumi.Output<boolean>;
    readonly image?: pulumi.Output<string>;
    readonly initImage?: pulumi.Output<string>;
    readonly logFile?: pulumi.Output<string>;
    readonly logLevel?: pulumi.Output<string>;
    readonly nodePortSupport?: pulumi.Output<boolean>;
    readonly securityContextPrivileged?: pulumi.Output<boolean>;
    readonly vethPrefix?: pulumi.Output<string>;
    readonly warmEniTarget?: pulumi.Output<number>;
    readonly warmIpTarget?: pulumi.Output<number>;
    readonly warmPrefixTarget?: pulumi.Output<number>;
}
export interface Cluster_getKubeconfigInputs {
    readonly __self__: pulumi.Input<Cluster>;
    readonly profileName?: pulumi.Input<string>;
    readonly roleArn?: pulumi.Input<string>;
}
export interface Cluster_getKubeconfigOutputs {
    readonly result: pulumi.Output<string>;
}
